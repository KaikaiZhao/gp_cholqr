function [P, G, Q, R, Dadv, QGG, infoQ, infoR, D, usedInfoPInds, pp_age, RIPParams, size_params] = ...
                                       cholQRSwapUpdate(size_params,...
                                                        Y, ...
                                                        P,...
                                                        trainx,...
                                                        diagK, ... 
                                                        K, ...
                                                        G, ...
                                                        Q, ...
                                                        R, ...
                                                        Dadv, ...
                                                        QGG,...
                                                        infoQ,...
                                                        infoR,...
                                                        noise_var,...
                                                        D,...
                                                        usedInfoPInds,...
                                                        pp_age, ... 
                                                        RIPParams,...
                                                        do_var_cost)


if ~exist('do_var_cost', 'var') 
    do_var_cost = false;
end

ik_swap = size_params.ik_swap;
k = size_params.k;
kadv = size_params.kadv;
 
size_params.ik_down = ik_swap;
 
if do_var_cost
[old_cost, old_data_fit, old_complexity, old_trvar] = ...
                            cholQR_nvf_from_factors(diagK(P),...
                                                    G,...
                                                    Y(P), ...
                                                    Q, ...
                                                    R,...
                                                    noise_var, ...
                                                    size_params.n, ...
                                                    size_params.k);    
else
[old_cost, old_data_fit, old_complexity] = ...
                           cholQR_nmll_from_factors(Y(P), ...
                                                    Q, ...
                                                    R,...
                                                    noise_var, ...
                                                    size_params.n, ...
                                                    size_params.k);
end

old_P = P;
old_G = G;
old_Q = Q;
old_R = R;
old_Dadv = Dadv;
old_D = D;
old_infoQ = infoQ;
old_infoR = infoR;
old_usedInfoPInds = usedInfoPInds;
old_QGG = QGG;
old_size_params = size_params;
old_pp_age = pp_age;

%ik_swap_age = pp_age(size_params.ik_down); we do want to reset the age to zero
%even if it turns that swapping is not needed, because age is the age we havent
%revisited the pivots

[size_params.k, ...
 size_params.kadv, ...
 P, ...
 G, ...
 Q, ...
 R, ...
 Dadv, ...
 QGG, ...
 infoQ, ...
 infoR, ...
 D, ...
 usedInfoPInds, ...
 pp_age] = ...
            cholQRLowRankDowndate(size_params,...
                                  P, ...
                                  G, ...
                                  Q, ...
                                  R, ...
                                  Dadv, ...
                                  QGG,...
                                  infoQ,...
                                  infoR,...
                                  D, ...
                                  usedInfoPInds,...
                                  pp_age);
                              
if isempty(QGG)
    [deltaNmll, deltaJY, deltaJC, deltaJV] = cholQRApproxUpdateCosts(size_params,...
                                                        Y(P), ...
                                                        D, ...
                                                        G, ...
                                                        Q, ...
                                                        noise_var,...
                                                        [],...
                                                        infoR, do_var_cost);
else
[deltaNmll, deltaJY, deltaJC, deltaJV] = cholQRApproxUpdateCosts(size_params,...
                                                        Y(P), ...
                                                        D, ...
                                                        G, ...
                                                        Q, ...
                                                        noise_var,...
                                                        QGG(:,size_params.k:size_params.n),...
                                                        infoR, do_var_cost);
end

if do_var_cost
    
[base_cost, base_data_fit, base_complexity, base_var] = ...
                        cholQR_nvf_from_factors(diagK(P),...
                                                G,...
                                                Y(P), ...
                                                Q, ...
                                                R, ...
                                                noise_var, ...
                                                size_params.n, ...
                                                size_params.k);    
                                            
else

[base_cost, base_data_fit, base_complexity] = ...
    cholQR_nmll_from_factors(Y(P), ...
                             Q, ...
                             R, ...
                             noise_var, ...
                             size_params.n, ...
                             size_params.k);
end                         
%% DEBUG
%  
%     true_deltaCost = -inf(size_params.n,1);
%     true_deltaJY  = -inf(size_params.n,1);
%     true_deltaJC  = -inf(size_params.n,1);
%     true_deltaJV  = -inf(size_params.n,1);
%     
%     for ii = size_params.k:size_params.n
%         
%         [true_cost  , true_JY  , true_JC , true_JVar , numericalErrLarge] = ...
%             computeExactCostForOnePivot(trainx, diagK(P), K, P, Y, Dadv, G, noise_var, ...
%                                         size_params.k, size_params.kadv, ii, [], [], [] ,do_var_cost);
%                                     
%         true_deltaCost(ii) = base_cost          - true_cost;
%         true_deltaJY(ii)   = base_data_fit      - true_JY;
%         true_deltaJC(ii)   = base_complexity    - true_JC;
%         true_deltaJV(ii)   = base_var           - true_JVar;
%         
%     end
%     
% %     size_params_db = size_params;
% %     for ii = size_params.k:size_params.n
% %         size_params_db.ik_best = ii;
% %         
% %         [true_deltaCost(ii)   , true_deltaJY(ii)   , true_deltaJC(ii)   ] = ...
% %                              cholQRFastExactUpdateCostForOnePivot(size_params_db, ...
% %                                                                  Y(P),...
% %                                                                  P,...
% %                                                                  D,...
% %                                                                  G,...
% %                                                                  Q,...
% %                                                                  noise_var, ...
% %                                                                  K,...
% %                                                                  trainx);
% %             
% %    
% %     end
%     
%     plotExactAndApproxCosts_separate('snelson_1D_',true_deltaCost , true_deltaJY , true_deltaJC,  true_deltaJV ,...
%                             deltaNmll, deltaJY, deltaJC, deltaJV, ...
%                             size_params.k, size_params.n );
   
    
 

%% pick the best according to approximate cost
score_to_ensure_pos = Dadv;
score_to_ensure_pos(size_params.k:size_params.kadv) = D(size_params.k:size_params.kadv);
[ik_best, Jmax] = getMaxInd(deltaNmll, k, score_to_ensure_pos, 1e-6);

if ik_best == kadv+1
    fprintf('%d was downdated then restored\n',ik_swap);
end
size_params.ik_best = ik_best;
 
%% This is a hack
if isProperlySet(RIPParams, 'estimate_rejection_rates')
    global proposed_i proposed_j is_accepted
    proposed_i = [proposed_i P(ik_swap)];
    proposed_j = [proposed_i P(ik_best)];
end
%% first quickly check if it's gonna improve
[true_cost, true_deltaJY, true_deltaJC, true_deltaJVar] = ...
                            cholQRFastExactUpdateCostForOnePivot(size_params, ...
                                                                 Y(P),...
                                                                 P,...
                                                                 D,...
                                                                 G,...
                                                                 Q,...
                                                                 noise_var, ...
                                                                 K,...
                                                                 trainx, ...
                                                                 do_var_cost);
                                                             

% NEW: "sufficient decrease" type of condition for proposal acceptance, 
% This is more strict than the previous (base_cost - true_cost) < old_cost,
% for acceptance. 
% This improves the performance a little, especially using coarser
% approximations; but it might cause high rejection rate, especially
% towards the end of optimization, which is not an issue (in fact desirable)

if ~((old_cost - (base_cost - true_cost)) / abs(old_cost) > 1e-6)
        %&& rand < .5
   P = old_P;
   G = old_G;
   Q = old_Q;
   R = old_R;
   Dadv = old_Dadv;
   D = old_D;
   infoQ = old_infoQ;
   infoR = old_infoR;
   QGG = old_QGG;
   usedInfoPInds = old_usedInfoPInds;
   pp_age = old_pp_age;
   size_params = old_size_params;
   
   %fprintf('Proposal to replace %d by %d is rejected :( \n', ik_swap, ik_best);
%    if isProperlySet(RIPParams,'adapt_info_size_rate')
%        
%        assert(isempty(QGG),'caching not implemented for adaptive info size!!!');
%        
%        tmp_delta = ceil((size_params.kadv - size_params.k + 1)*RIPParams.adapt_info_size_rate);
%        tmp_delta = min(tmp_delta, size_params.delta);
%        new_kadv = size_params.k + tmp_delta - 1;
%    else
%        new_kadv = [];
%    end
 
   if isProperlySet(RIPParams, 'estimate_rejection_rates')
       is_accepted = [is_accepted false];
   end
   
else
 
    
    
    if isProperlySet(RIPParams, 'estimate_rejection_rates')
        is_accepted = [is_accepted true];
    end
    
%  fprintf('Proposal to replace %d by %d is accepted :P\n', ik_swap, ik_best);

 

   % NOTE: we don't need to swap or update pp_age, because swap_update moves
   % new pivot from far beyond to kadv + 1, then permute update to swap it to k-1,
   % as long as at k-1 position, the age was already set to 0 (by
   % cholQRLowRankDowndate), we are good
   
   [size_params.k, size_params.kadv, ~ , P, G, Q, R, Dadv, QGG, infoQ, infoR, D, usedInfoPInds] = ...
                                            cholQRLowRankUpdate(size_params, ...
                                                                trainx,...
                                                                K, ...
                                                                P, ...
                                                                G, ...
                                                                Q,...
                                                                R, ...
                                                                Dadv, ...
                                                                QGG,...
                                                                infoQ,...
                                                                infoR,...
                                                                noise_var, ...
                                                                D, ...
                                                                usedInfoPInds);   
                                                            
%     if isProperlySet(RIPParams,'adapt_info_size_rate')
%         assert(isempty(QGG),'caching not implemented for adaptive info size!!!');
%         new_kadv = max(size_params.k + 1, size_params.kadv - 1);
%     else
%         new_kadv = [];
%     end
                                                        
end                                                             
  
[reInfoNeeded, RIPParams] = checkIfReInfoNeeded(RIPParams, D, Dadv, Jmax, ik_swap);


if reInfoNeeded
    
        [P, G, Q, R, Dadv, D, usedInfoPInds] = ...
                        cholQRRevisitInfoPivots(size_params,...
                                                trainx,...
                                                K, ...
                                                P, ...
                                                G, ...
                                                Q,...
                                                R, ...
                                                Dadv, ...
                                                noise_var, ... 
                                                D, ...
                                                usedInfoPInds,...
                                                RIPParams);
        
end

% if ~isempty(new_kadv)
%     assert((new_kadv - size_params.k + 1) <= size_params.delta);
%     assert(new_kadv >= size_params.k + 1);
%     
%     %%
%  
%     
%     n = size_params.n;
% 
%     if new_kadv < size_params.kadv
%         assert(new_kadv == size_params.kadv -1);
%         
%         Dadv(size_params.kadv+1:n) =  Dadv(size_params.kadv+1:n) + ...
%                                         G(size_params.kadv+1:n, size_params.kadv).^2;
%                                     
%         Dadv(size_params.kadv) = G(size_params.kadv, size_params.kadv).^2;
%         
%         G(:,size_params.kadv) = 0;
%         Q(:,size_params.kadv) = 0;
%         R(1:size_params.kadv, size_params.kadv) = 0;
%         R(size_params.kadv, 1:size_params.kadv) = 0;
%         
%         size_params.kadv = new_kadv;
%         fprintf('Reduced current delta to %d\n', size_params.kadv - size_params.k + 1);
%         
%     elseif new_kadv > size_params.kadv
%         info_pivots_inds  = (size_params.kadv+1):new_kadv;
%         NP = numel(info_pivots_inds);
%         for p = 1:NP
%             info_p = info_pivots_inds(p);
%  
%             if all(usedInfoPInds(kadv:end))  
%                 %all the remaining ones have served as info pivots before, clear queue
%                 usedInfoPInds = false(size(P));
%             end
% 
%             if isProperlySet(RIPParams,'use_rand_info') && RIPParams.use_rand_info
%                 scores = rand(size(Dadv));
%                 scores(1:size_params.kadv) = 0;
%             else
%                 scores = Dadv;
%                 scores(usedInfoPInds) = 0;
%             end
% 
%             [info_ik_best, ~] = getMaxInd(scores, info_p, Dadv, 1e-10);
%             
%             if  Dadv(info_ik_best) <= 1e-5
%                 %numerical problem, reset the queue
%                 usedInfoPInds = false(size(P));
%                 
%                 if isProperlySet(RIPParams,'use_rand_info') && RIPParams.use_rand_info
%                     scores = rand(size(Dadv));
%                     scores(1:size_params.kadv) = 0;
%                 else
%                     scores = Dadv;
%                     scores(usedInfoPInds) = 0;
%                 end
%                 
%                 [info_ik_best, ~] = getMaxInd(scores, info_p, Dadv, 1e-10);
%             end
%             
%             size_params.kadv = size_params.kadv + 1;
%             
%             info_size_params = size_params;
%             info_size_params.info_ik_best = info_ik_best;
%             
%             
%             
%             [P, G, Dadv, D, usedInfoPInds, Q(:,1:info_size_params.k)] = ...
%                                             cholOneStep(info_size_params.info_ik_best , ...
%                                                         info_size_params.kadv,...
%                                                         trainx,...
%                                                         K, ...
%                                                         P, ...
%                                                         G, ...
%                                                         Dadv, ...
%                                                         noise_var,...
%                                                         D, ...
%                                                         usedInfoPInds, ...
%                                                         Q(:,1:info_size_params.k));
%  
%             
%         end
%         
%         assert(new_kadv == size_params.kadv);
%         fprintf('Increased current delta to %d\n', size_params.kadv - size_params.k + 1);
%     end
%     
%     
%     
%     
% end
% 
% if (reInfoNeeded || ~isempty(new_kadv)) && ~isempty(QGG)
%     [QGG, infoQ, infoR] = cacheValueBatchCompute(size_params, Q,G);
% end

if reInfoNeeded && ~isempty(QGG)
    [QGG, infoQ, infoR] = cacheValueBatchCompute(size_params, Q,G);
end

end

 
